"use strict";(self.webpackChunkfmodel_ts_doc=self.webpackChunkfmodel_ts_doc||[]).push([[688],{7863:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>u,default:()=>h,frontMatter:()=>d,metadata:()=>o,toc:()=>l});var r=t(4848),a=t(8453),s=t(1470),i=t(9365);const d={sidebar_position:3},u="Modeling the Behaviour",o={id:"domain/modeling-the-behaviour",title:"Modeling the Behaviour",description:"- algebraic data types form the structure of our entities (commands, state, and events)",source:"@site/docs/domain/modeling-the-behaviour.md",sourceDirName:"domain",slug:"/domain/modeling-the-behaviour",permalink:"/fmodel-ts/docs/domain/modeling-the-behaviour",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/domain/modeling-the-behaviour.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Structuring the data",permalink:"/fmodel-ts/docs/domain/structuring-the-data"},next:{title:"Aggregating the Behaviour",permalink:"/fmodel-ts/docs/domain/aggregating-the-behaviour"}},c={},l=[{value:"Decider",id:"decider",level:2},{value:"View",id:"view",level:2},{value:"Saga",id:"saga",level:2},{value:"Totality",id:"totality",level:2}];function m(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"modeling-the-behaviour",children:"Modeling the Behaviour"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["algebraic data types form the ",(0,r.jsx)(n.code,{children:"structure"})," of our entities (commands, state, and events)"]}),"\n",(0,r.jsxs)(n.li,{children:["functions/lambda offers the algebra of manipulating the entities in a compositional manner, effectively modeling\nthe ",(0,r.jsx)(n.code,{children:"behavior."})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This leads to modularity in design and a clear separation of the entity\u2019s structure and functions/",(0,r.jsx)(n.code,{children:"behaviour"})," of the\nentity."]}),"\n",(0,r.jsx)(n.p,{children:"Fmodel offers generic and abstract components to specialize in for your specific case/expected behavior:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Decider"}),"\n",(0,r.jsx)(n.li,{children:"View"}),"\n",(0,r.jsx)(n.li,{children:"Saga"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"decider",children:"Decider"}),"\n",(0,r.jsx)(n.p,{children:"The decider is a data type that represents the main decision-making algorithm."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"initialState"})," - A starting point / An initial state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"decide"})," (Exhaustive / pattern matching command handler) - A function/lambda that takes command and input state as\nparameters, and returns/emits the flow of output events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"evolve"})," (Exhaustive / pattern matching event-sourcing handler) - A function/lambda that takes input state and input\nevent as parameters, and returns the output/new state"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"decider image",src:t(7957).A+"",width:"1873",height:"1488"})}),"\n",(0,r.jsxs)(s.A,{groupId:"concept",queryString:"concept",children:[(0,r.jsx)(i.A,{value:"restaurant",label:"Restaurant",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const restaurantDecider: Decider<\n  RestaurantCommand,\n  Restaurant | null,\n  RestaurantEvent\n> = new Decider<RestaurantCommand, Restaurant | null, RestaurantEvent>(\n  (command, currentState) => {\n    switch (command.kind) {\n      case "CreateRestaurantCommand":\n        return (currentState === null ||\n            currentState.restaurantId === undefined)\n          ? [\n            {\n              version: 1,\n              decider: "Restaurant",\n              kind: "RestaurantCreatedEvent",\n              id: command.id,\n              name: command.name,\n              menu: command.menu,\n              final: false,\n            },\n          ]\n          : [\n            {\n              version: 1,\n              decider: "Restaurant",\n              kind: "RestaurantNotCreatedEvent",\n              id: command.id,\n              name: command.name,\n              menu: command.menu,\n              reason: "Restaurant already exist!",\n              final: false,\n            },\n          ];\n      case "ChangeRestaurantMenuCommand":\n        return (currentState !== null &&\n            currentState.restaurantId === command.id)\n          ? [\n            {\n              version: 1,\n              decider: "Restaurant",\n              kind: "RestaurantMenuChangedEvent",\n              id: currentState.restaurantId,\n              menu: command.menu,\n              final: false,\n            },\n          ]\n          : [\n            {\n              version: 1,\n              decider: "Restaurant",\n              kind: "RestaurantMenuNotChangedEvent",\n              id: command.id,\n              menu: command.menu,\n              reason: "Restaurant does not exist!",\n              final: false,\n            },\n          ];\n      case "PlaceOrderCommand":\n        return (currentState !== null &&\n            currentState.restaurantId === command.id)\n          ? [\n            {\n              version: 1,\n              decider: "Restaurant",\n              kind: "RestaurantOrderPlacedEvent",\n              id: command.id,\n              orderId: command.orderId,\n              menuItems: command.menuItems,\n              final: false,\n            },\n          ]\n          : [\n            {\n              version: 1,\n              decider: "Restaurant",\n              kind: "RestaurantOrderNotPlacedEvent",\n              id: command.id,\n              orderId: command.orderId,\n              menuItems: command.menuItems,\n              reason: "Restaurant does not exist!",\n              final: false,\n            },\n          ];\n      default: {\n        // Exhaustive matching of the command type\n        const _: never = command;\n        return [];\n      }\n    }\n  },\n  (currentState, event) => {\n    switch (event.kind) {\n      case "RestaurantCreatedEvent":\n        return { restaurantId: event.id, name: event.name, menu: event.menu };\n      case "RestaurantNotCreatedEvent":\n        return currentState;\n      case "RestaurantMenuChangedEvent":\n        return currentState !== null\n          ? {\n            restaurantId: currentState.restaurantId,\n            name: currentState.name,\n            menu: event.menu,\n          }\n          : currentState;\n      case "RestaurantMenuNotChangedEvent":\n        return currentState;\n      case "RestaurantOrderPlacedEvent":\n        return currentState;\n      case "RestaurantOrderNotPlacedEvent":\n        return currentState;\n      default: {\n        const _: never = event;\n        return currentState;\n      }\n    }\n  },\n  null,\n);\n'})})}),(0,r.jsx)(i.A,{value:"order",label:"Order",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const orderDecider: Decider<OrderCommand, Order | null, OrderEvent> =\n  new Decider<OrderCommand, Order | null, OrderEvent>(\n    (command, currentState) => {\n      switch (command.kind) {\n        case "CreateOrderCommand":\n          return (currentState === null || currentState.orderId === undefined)\n            ? [\n              {\n                version: 1,\n                decider: "Order",\n                kind: "OrderCreatedEvent",\n                id: command.id,\n                restaurantId: command.restaurantId,\n                menuItems: command.menuItems,\n                final: false,\n              },\n            ]\n            : [\n              {\n                version: 1,\n                decider: "Order",\n                kind: "OrderNotCreatedEvent",\n                id: command.id,\n                restaurantId: command.restaurantId,\n                menuItems: command.menuItems,\n                final: false,\n                reason: "Order already exist!",\n              },\n            ];\n        case "MarkOrderAsPreparedCommand":\n          return (currentState !== null && currentState.orderId === command.id)\n            ? [\n              {\n                version: 1,\n                decider: "Order",\n                kind: "OrderPreparedEvent",\n                id: currentState.orderId,\n                final: false,\n              },\n            ]\n            : [\n              {\n                version: 1,\n                decider: "Order",\n                kind: "OrderNotPreparedEvent",\n                id: command.id,\n                reason: "Order does not exist!",\n                final: false,\n              },\n            ];\n        default: {\n          // Exhaustive matching of the command type\n          const _: never = command;\n          return [];\n        }\n      }\n    },\n    (currentState, event) => {\n      switch (event.kind) {\n        case "OrderCreatedEvent":\n          return {\n            orderId: event.id,\n            restaurantId: event.restaurantId,\n            menuItems: event.menuItems,\n            status: "CREATED",\n          };\n        case "OrderNotCreatedEvent":\n          return currentState;\n        case "OrderPreparedEvent":\n          return currentState !== null\n            ? {\n              orderId: currentState.orderId,\n              restaurantId: currentState.restaurantId,\n              menuItems: currentState.menuItems,\n              status: "PREPARED",\n            }\n            : currentState;\n        case "OrderNotPreparedEvent":\n          return currentState;\n        default: {\n          // Exhaustive matching of the event type\n          const _: never = event;\n          return currentState;\n        }\n      }\n    },\n    null,\n  );\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"view",children:"View"}),"\n",(0,r.jsx)(n.p,{children:"The view is a data type that represents the event handling algorithm responsible for translating the events into the\ndenormalized state, which is adequate for querying."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"initialState"})," - A starting point / An initial state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"evolve"})," (Exhaustive / pattern matching event handler) - A function/lambda that takes input state and input event as\nparameters, and returns the output/new state"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"view image",src:t(2890).A+"",width:"1510",height:"929"})}),"\n",(0,r.jsxs)(s.A,{groupId:"concept",queryString:"concept",children:[(0,r.jsx)(i.A,{value:"restaurant",label:"Restaurant",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const restaurantView: View<RestaurantView | null, RestaurantEvent> =\n  new View<RestaurantView | null, RestaurantEvent>(\n    (currentState, event) => {\n      switch (event.kind) {\n        case "RestaurantCreatedEvent":\n          return { restaurantId: event.id, name: event.name, menu: event.menu };\n        case "RestaurantNotCreatedEvent":\n          return currentState;\n        case "RestaurantMenuChangedEvent":\n          return currentState !== null\n            ? {\n              restaurantId: currentState.restaurantId,\n              name: currentState.name,\n              menu: event.menu,\n            }\n            : currentState;\n        case "RestaurantMenuNotChangedEvent":\n          return currentState;\n        case "RestaurantOrderPlacedEvent":\n          return currentState;\n        case "RestaurantOrderNotPlacedEvent":\n          return currentState;\n        default: {\n          // Exhaustive matching of the event type\n          const _: never = event;\n          return currentState;\n        }\n      }\n    },\n    null,\n  );\n'})})}),(0,r.jsx)(i.A,{value:"order",label:"Order",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const orderView: View<OrderView | null, OrderEvent> = new View<\n  OrderView | null,\n  OrderEvent\n>(\n  (currentState, event) => {\n    switch (event.kind) {\n      case "OrderCreatedEvent":\n        return {\n          orderId: event.id,\n          restaurantId: event.restaurantId,\n          menuItems: event.menuItems,\n          status: "CREATED",\n        };\n      case "OrderNotCreatedEvent":\n        return currentState;\n      case "OrderPreparedEvent":\n        return currentState !== null\n          ? {\n            orderId: currentState.orderId,\n            restaurantId: currentState.restaurantId,\n            menuItems: currentState.menuItems,\n            status: "PREPARED",\n          }\n          : currentState;\n      case "OrderNotPreparedEvent":\n        return currentState;\n      default: {\n        // Exhaustive matching of the event type\n        const _: never = event;\n        return currentState;\n      }\n    }\n  },\n  null,\n);\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"saga",children:"Saga"}),"\n",(0,r.jsx)(n.p,{children:"Saga is a data type that represents the central point of control, deciding what to execute next. It is responsible for\nmapping different events from deciders into action results that the Saga then can use to calculate the subsequent\nactions to be\nmapped to the command of other deciders."}),"\n",(0,r.jsx)(n.p,{children:"In the context of smart endpoints and dumb pipes, deciders would be smart endpoints, and saga would be a dumb pipe."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"react"})," - A function/lambda that takes input action-result/event, and returns the flow of actions/commands that should\nbe published."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"saga image",src:t(4167).A+"",width:"2129",height:"679"})}),"\n",(0,r.jsxs)(s.A,{groupId:"concept",queryString:"concept",children:[(0,r.jsx)(i.A,{value:"restaurant",label:"Restaurant",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const restaurantSaga: Saga<OrderEvent, RestaurantCommand> = new Saga(\n  (event) => {\n    switch (event.kind) {\n      case "OrderPreparedEvent":\n      case "OrderNotPreparedEvent":\n      case "OrderCreatedEvent":\n      case "OrderNotCreatedEvent":\n        return [];\n      default: {\n        // Exhaustive matching of the Action Result/Event type\n        const _: never = event;\n        return [];\n      }\n    }\n  },\n);\n'})})}),(0,r.jsx)(i.A,{value:"order",label:"Order",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export const orderSaga: Saga<RestaurantEvent, OrderCommand> = new Saga<\n  RestaurantEvent,\n  OrderCommand\n>(\n  (event) => {\n    switch (event.kind) {\n      case "RestaurantOrderPlacedEvent":\n        return [\n          {\n            decider: "Order",\n            kind: "CreateOrderCommand",\n            id: event.orderId,\n            restaurantId: event.id,\n            menuItems: event.menuItems,\n          },\n        ];\n      case "RestaurantCreatedEvent":\n      case "RestaurantNotCreatedEvent":\n      case "RestaurantMenuChangedEvent":\n      case "RestaurantMenuNotChangedEvent":\n      case "RestaurantOrderNotPlacedEvent":\n        return [];\n      default: {\n        // Exhaustive matching of the Action Result/Event type\n        const _: never = event;\n        return [];\n      }\n    }\n  },\n);\n'})})})]}),"\n",(0,r.jsx)(n.h2,{id:"totality",children:"Totality"}),"\n",(0,r.jsxs)(n.p,{children:["A function is ",(0,r.jsx)(n.code,{children:"total"})," if it is defined for all of its possible inputs."]}),"\n",(0,r.jsxs)(n.p,{children:["By having algebraic data types modeling the ",(0,r.jsx)(n.code,{children:"Sum/OR"})," relationship with ",(0,r.jsx)(n.code,{children:"union"})," type, it's possible to verify that the ",(0,r.jsx)(n.code,{children:"switch"})," statement covers all cases."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"never"})," type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement."]}),"\n",(0,r.jsxs)(n.p,{children:["The compiler/transpiler will yell at you if you add a new command/event into the model/project (",(0,r.jsx)(n.code,{children:"switch"})," statement goes red), and\nyou will have to fix it immediately.\nIt will positively influence the function (",(0,r.jsx)(n.code,{children:"decide"}),", ",(0,r.jsx)(n.code,{children:"evolve"}),", ",(0,r.jsx)(n.code,{children:"react"}),") totality giving more guarantees about code\ncorrectness."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"The essence of functional programming lies in the power of pure functions. Add static types to the mix, and you have\nalgebraic abstractions\u2014functions operating on types and honoring certain laws. Make the functions generic on types, and\nyou have parametricity. The function becomes polymorphic, which implies more reusability, and if you\u2019re disciplined\nenough not to leak any implementation details by sneaking in specialized types (or unmanaged hazards such as\nexceptions), you get free theorems."})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var r=t(4164);const a={tabItem:"tabItem_Ymn6"};var s=t(4848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(a.tabItem,i),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>y});var r=t(6540),a=t(4164),s=t(3104),i=t(6347),d=t(205),u=t(7485),o=t(1682),c=t(679);function l(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return l(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}(t);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function v(e){let{queryString:n=!1,groupId:t}=e;const a=(0,i.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,u.aZ)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(a.location.search);n.set(s,e),a.replace({...a.location,search:n.toString()})}),[s,a])]}function p(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,s=m(e),[i,u]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s}))),[o,l]=v({queryString:t,groupId:a}),[p,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,s]=(0,c.Dv)(t);return[a,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:a}),g=(()=>{const e=o??p;return h({value:e,tabValues:s})?e:null})();(0,d.A)((()=>{g&&u(g)}),[g]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);u(e),l(e),f(e)}),[l,f,s]),tabValues:s}}var f=t(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function b(e){let{className:n,block:t,selectedValue:r,selectValue:i,tabValues:d}=e;const u=[],{blockElementScrollPositionUntilNextRender:o}=(0,s.a_)(),c=e=>{const n=e.currentTarget,t=u.indexOf(n),a=d[t].value;a!==r&&(o(n),i(a))},l=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},n),children:d.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>u.push(e),onKeyDown:l,onClick:c,...s,className:(0,a.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function j(e){let{lazy:n,children:t,selectedValue:s}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function E(e){const n=p(e);return(0,x.jsxs)("div",{className:(0,a.A)("tabs-container",g.tabList),children:[(0,x.jsx)(b,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function y(e){const n=(0,f.A)();return(0,x.jsx)(E,{...e,children:l(e.children)},String(n))}},7957:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/decider-ts-30bff16180307715fc29d17cd1fb15bf.png"},4167:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/saga-ts-1fd8dfc2acc39d6d43e664a39d3f411b.png"},2890:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/view-ts-1fceb630a412ce89a897c0a094c213a9.png"},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var r=t(6540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);