"use strict";(self.webpackChunkfmodel_ts_doc=self.webpackChunkfmodel_ts_doc||[]).push([[609],{7021:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var s=n(4848),i=n(8453),r=n(1470),o=n(9365);const a={sidebar_position:1},c="Architecture",l={id:"application/architecture",title:"Architecture",description:"We learned how to model the domain effectively by using types and functions.",source:"@site/docs/application/architecture.md",sourceDirName:"application",slug:"/application/architecture",permalink:"/fmodel-ts/docs/application/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/application/architecture.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Composing The Application",permalink:"/fmodel-ts/docs/category/composing-the-application"},next:{title:"Application",permalink:"/fmodel-ts/docs/application/"}},d={},h=[{value:"The Application layer",id:"the-application-layer",level:2},{value:"Event-sourced or State-stored systems",id:"event-sourced-or-state-stored-systems",level:2},{value:"View model",id:"view-model",level:4}];function u(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,s.jsxs)(t.p,{children:["We learned how to model the domain effectively by using types and functions.\nWe used ",(0,s.jsx)(t.code,{children:"decider"}),", ",(0,s.jsx)(t.code,{children:"view"}),", and ",(0,s.jsx)(t.code,{children:"saga"})," components from FModel library to model the behavior using pure functions."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"These components do not care about storing or fetching the data."}),"\n",(0,s.jsx)(t.li,{children:"They do not produce any side effects of this kind."}),"\n",(0,s.jsx)(t.li,{children:"They represent pure computation / pure logics of a program."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"domain components",src:n(8340).A+"",width:"3730",height:"1667"})}),"\n",(0,s.jsx)(t.p,{children:"Functional Programming emphasizes separating the pure logic of a program (algebras) and the runtime used to run it."}),"\n",(0,s.jsx)(t.h2,{id:"the-application-layer",children:"The Application layer"}),"\n",(0,s.jsxs)(t.p,{children:["The logic execution will be orchestrated by the outside components (application components) that use the domain\ncomponents (",(0,s.jsx)(t.code,{children:"decider"}),", ",(0,s.jsx)(t.code,{children:"view"}),", and ",(0,s.jsx)(t.code,{children:"saga"}),") to do the computations. These components will be responsible for fetching and\nsaving the data (suspended effects)."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"onion architecture image",src:n(7518).A+"",width:"3317",height:"3588"})}),"\n",(0,s.jsxs)(t.p,{children:["The arrows in the image show the direction of the dependency.\n",(0,s.jsx)(t.strong,{children:"Notice that all dependencies point inwards and that Domain does not depend on anybody or anything."})]}),"\n",(0,s.jsx)(t.p,{children:"Pushing these decisions from the core domain model is very valuable.\nBeing able to postpone them is a sign of good architecture."}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.p,{children:["This architectural style is known as ",(0,s.jsx)(t.code,{children:"Functional Core, Imperative Shell"}),". A bit simplified, it is characterized by two key architectural attributes:"]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"There is a core with the core business logic, and a shell that handles interactions with the outside world, such as persisting data in databases or providing UIs to interact with end users."}),"\n",(0,s.jsx)(t.li,{children:"The shell can call the core, but the core cannot call the shell and the core is even unaware of the existence of the shell. This is also known as the Dependency Rule (see, for example, Clean Architecture to learn more about this rule)."}),"\n"]}),(0,s.jsx)(t.p,{children:"It is similar to Hexagonal Architecture, Ports and Adapters, Clean Architecture, Onion Architecture which have these two attributes in common."})]}),"\n",(0,s.jsx)(t.h2,{id:"event-sourced-or-state-stored-systems",children:"Event-sourced or State-stored systems"}),"\n",(0,s.jsxs)(t.p,{children:["The domain model is explicitly modeling ",(0,s.jsx)(t.code,{children:"events"})," and ",(0,s.jsx)(t.code,{children:"state,"})," and this opens some interesting options:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["fetch ",(0,s.jsx)(t.code,{children:"events"}),", execute domain components/compute, and store new ",(0,s.jsx)(t.code,{children:"events"})," by appending to the previous events in the\nstorage / ",(0,s.jsx)(t.strong,{children:"event-sourced systems"})," / ",(0,s.jsx)(t.strong,{children:"event-stored systems"})]}),"\n",(0,s.jsxs)(t.li,{children:["fetch ",(0,s.jsx)(t.code,{children:"state"}),", execute domain components/compute, and store new ",(0,s.jsx)(t.code,{children:"state"})," by overwriting the previous state in the\nstorage / traditional / ",(0,s.jsx)(t.strong,{children:"state-stored systems"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"event-stored or state-stored",src:n(1226).A+"",width:"3537",height:"1123"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Event-Sourced systems are storing the ",(0,s.jsx)(t.code,{children:"events"})," in immutable storage by only appending."]}),"\n",(0,s.jsxs)(t.li,{children:["State-Stored systems are traditional systems that are only storing the current ",(0,s.jsx)(t.code,{children:"state"})," by overwriting the previous ",(0,s.jsx)(t.code,{children:"state"})," in the storage."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"It is important to realize that your core domain logic does not have to change in order to transit from one flavor to another!"}),"\n",(0,s.jsxs)(t.p,{children:["Fmodel exposes couple of types of repository interfaces/ports within the ",(0,s.jsx)(t.code,{children:"application"})," module to support these two flavors."]}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"State-stored systems are using single canonical model for writing and reading/presenting, by default."}),"\n",(0,s.jsx)(t.li,{children:"Event-stored/Event_sourced systems are split to command and view/query models, by default."}),"\n"]}),(0,s.jsx)(t.p,{children:"Fmodel is promoting robust event-driven systems only in case of Event-Sourced scenario."}),(0,s.jsx)(t.p,{children:"In case of State-Stored scenario, you are limited to Decider and StateStoredAggregate components only. View, MaterializedView, SagaManager components are not available/useful."})]}),"\n",(0,s.jsxs)(r.A,{groupId:"system-type",queryString:"system-type",children:[(0,s.jsx)(o.A,{value:"event-stored",label:"Event-Stored / Event-Sourced",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IEventRepository"})," - responsible for storing and fetching the events of deciders"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IViewStateRepository"})," - responsible for storing and fetching the state of materialized views"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IActionPublisher"})," - responsible for publishing new actions/commands"]}),"\n"]})}),(0,s.jsx)(o.A,{value:"state-stored",label:"State-Stored",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IStateRepository"})," - responsible for storing and fetching the state of deciders"]}),"\n"]})})]}),"\n",(0,s.jsxs)(t.p,{children:["You can now compose these repository interfaces with the domain components (",(0,s.jsx)(t.code,{children:"decider"}),") in order to implement any of\nthese options (event-stored or state-stored system):"]}),"\n",(0,s.jsxs)(r.A,{groupId:"system-type",queryString:"system-type",children:[(0,s.jsxs)(o.A,{value:"event-stored",label:"Event-Stored / Event-Sourced",children:[(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const currentEvents = await this.eventRepository.fetch(command);\n\nconst currentState = currentEvents.reduce(\n      this.decider.evolve,\n      this.decider.initialState\n    );\nconst newEvents = this.decider.decide(command, currentState)\n\nthis.eventRepository.save(\n      newEvents,\n      command\n    );\n"})}),(0,s.jsxs)(t.p,{children:["An event-stored system is fetching the events by using the ",(0,s.jsx)(t.code,{children:"fetchEvents"})," method from the ",(0,s.jsx)(t.code,{children:"event repository"}),".\nIt then evolves the state based on the fetched events and delegates the state and the command to the ",(0,s.jsx)(t.code,{children:"decider"})," component\nwhich will produce new events by executing the ",(0,s.jsx)(t.code,{children:"decide"})," function.\nFinally, the events will be stored via the ",(0,s.jsx)(t.code,{children:"save"})," function from the ",(0,s.jsx)(t.code,{children:"event repository"}),"."]}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"event-modeling-event-driven-systems",src:n(8946).A+"",width:"5391",height:"3776"})}),(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["The implementation of the ",(0,s.jsx)(t.code,{children:"event repository"})," is not part of the ",(0,s.jsx)(t.code,{children:"Application"})," layer. It is delegated to the outside\nInfrastructure/Adapter layers."]})}),(0,s.jsx)(t.p,{children:"With event-stored approach we are effectively splitting the domain model into"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"command model / for writing"}),"\n",(0,s.jsx)(t.li,{children:"view/query model / for querying"}),"\n"]}),(0,s.jsx)(t.p,{children:"States of both, command model/yellow and view model/green, are evolved out of the same events.\nThis is making a huge difference, as now you have multiple view models independently serving every page/step in the flow\nwith the data it requires, making these steps decoupled."}),(0,s.jsx)(t.p,{children:"We are not limited to use a single canonical model for writing and reading/presenting!"}),(0,s.jsx)(t.h4,{id:"view-model",children:"View model"}),(0,s.jsxs)(t.p,{children:["The ViewStateRepository can be composed with the ",(0,s.jsx)(t.code,{children:"view"})," domain component:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const currentState = await this.viewStateRepository.fetch(event);\n\nconst newState = this.view.evolve(\n  currentState? currentState : this.view.initialState,\n  event\n);\n\nthis.viewStateRepository.save(newState);\n"})}),(0,s.jsxs)(t.p,{children:["A event-stored system is fetching the current view state by using the ",(0,s.jsx)(t.code,{children:"fetchState"})," method from\nthe ",(0,s.jsx)(t.code,{children:"view state repository"}),".\nFinally, the event will fold to the new state by using the ",(0,s.jsx)(t.code,{children:"view"})," ",(0,s.jsx)(t.code,{children:"evolve"})," function, and the new state will be stored\nvia the ",(0,s.jsx)(t.code,{children:"save"})," function from the ",(0,s.jsx)(t.code,{children:"view state repository"}),"."]}),(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["The implementation of the ",(0,s.jsx)(t.code,{children:"view state repository"})," is not part of the ",(0,s.jsx)(t.code,{children:"Application"})," layer. It is delegated to the outside\nInfrastructure/Adapter layers."]})})]}),(0,s.jsxs)(o.A,{value:"state-stored",label:"State-Stored",children:[(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const currentState = await this.stateRepository.fetch(command);\n\nconst newEvents = this.decider.decide(command, currentState);\nconst newState = newEvents.reduce(this.decider.evolve, currentState);\n\nthis.stateRepository.save(newState);\n"})}),(0,s.jsxs)(t.p,{children:["A state-stored system is fetching the current state by using the ",(0,s.jsx)(t.code,{children:"fetchState"})," method from the ",(0,s.jsx)(t.code,{children:"state repository"}),".\nIt then delegates the command and the current state to the ",(0,s.jsx)(t.code,{children:"decider"})," which will produce a new list of events by\nexecuting the ",(0,s.jsx)(t.code,{children:"decide"})," function.\nFinally, the list of events will fold to the new state by using the ",(0,s.jsx)(t.code,{children:"decider"})," ",(0,s.jsx)(t.code,{children:"evolve"})," function, and the new state will\nbe stored via the ",(0,s.jsx)(t.code,{children:"save"})," function from the ",(0,s.jsx)(t.code,{children:"state repository"}),"."]}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"event-modeling-traditional-systems",src:n(7852).A+"",width:"5480",height:"5461"})}),(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["The implementation of the ",(0,s.jsx)(t.code,{children:"state repository"})," is not part of the ",(0,s.jsx)(t.code,{children:"Application"})," layer. It is delegated to the outside\nInfrastructure/Adapter layers."]})}),(0,s.jsx)(t.p,{children:"State-stored systems are using single canonical model for writing and reading/presenting, by default.\nThe single state is represented with the yellow color on the image."})]})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Fmodel offers application interfaces/components which are actually composed out of side-effects (repository interfaces) and core domain logic (decider, view, saga),\nproviding a default implementation and formalizing the concepts we just described:"})}),"\n",(0,s.jsxs)(r.A,{groupId:"system-type",queryString:"system-type",children:[(0,s.jsx)(o.A,{value:"event-stored",label:"Event-Stored / Event-Sourced",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"IEventSourcingAggregate"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"IMaterializedView"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"ISagaManager"})}),"\n"]})}),(0,s.jsx)(o.A,{value:"state-stored",label:"State-Stored",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"IStateStoredAggregate"})}),"\n"]})})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>o});n(6540);var s=n(4164);const i={tabItem:"tabItem_Ymn6"};var r=n(4848);function o(e){let{children:t,hidden:n,className:o}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.A)(i.tabItem,o),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>w});var s=n(6540),i=n(4164),r=n(3104),o=n(6347),a=n(205),c=n(7485),l=n(1682),d=n(679);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:i}}=e;return{value:t,label:n,attributes:s,default:i}}))}(n);return function(e){const t=(0,l.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const i=(0,o.W6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,c.aZ)(r),(0,s.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(i.location.search);t.set(r,e),i.replace({...i.location,search:t.toString()})}),[r,i])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,r=u(e),[o,c]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:r}))),[l,h]=m({queryString:n,groupId:i}),[f,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,r]=(0,d.Dv)(n);return[i,(0,s.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:i}),v=(()=>{const e=l??f;return p({value:e,tabValues:r})?e:null})();(0,a.A)((()=>{v&&c(v)}),[v]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),g(e)}),[h,g,r]),tabValues:r}}var g=n(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=n(4848);function j(e){let{className:t,block:n,selectedValue:s,selectValue:o,tabValues:a}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),i=a[n].value;i!==s&&(l(t),o(i))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},t),children:a.map((e=>{let{value:t,label:n,attributes:r}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>c.push(e),onKeyDown:h,onClick:d,...r,className:(0,i.A)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:r}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function b(e){const t=f(e);return(0,x.jsxs)("div",{className:(0,i.A)("tabs-container",v.tabList),children:[(0,x.jsx)(j,{...t,...e}),(0,x.jsx)(y,{...t,...e})]})}function w(e){const t=(0,g.A)();return(0,x.jsx)(b,{...e,children:h(e.children)},String(t))}},8340:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/domain-components-b3f681619b0b943e0e84fd08ac5df919.png"},1226:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/es-ss-066c45b7c26a4a0a52fb8e3cd05be5e9.png"},8946:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/event-modeling-event-driven-systems-dd36561b4d665e5dfcc97acc8fccbf92.png"},7852:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/event-modeling-traditional-systems-1f8ef3235fa73ccc9ec41b05082804da.png"},7518:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/onion-0e7a4667c3d94945d08c62a84ad6e063.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);