"use strict";(self.webpackChunkfmodel_ts_doc=self.webpackChunkfmodel_ts_doc||[]).push([[389],{7822:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>g});var a=t(4848),r=t(8453),o=t(1470),s=t(9365);const i={sidebar_position:2},d="Application",c={id:"application/application",title:"Application",description:"The only responsibility of the application layer is to orchestrate the execution of the logic by",source:"@site/docs/application/application.md",sourceDirName:"application",slug:"/application/",permalink:"/fmodel-ts/docs/application/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/application/application.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Architecture",permalink:"/fmodel-ts/docs/application/architecture"},next:{title:"Examples",permalink:"/fmodel-ts/docs/application/example"}},l={},g=[{value:"Event-Sourced vs State-Stored",id:"event-sourced-vs-state-stored",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"application",children:"Application"})}),"\n",(0,a.jsx)(n.p,{children:"The only responsibility of the application layer is to orchestrate the execution of the logic by"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"loading the state from a repository"}),"\n",(0,a.jsx)(n.li,{children:"execute logic by executing domain layer components"}),"\n",(0,a.jsx)(n.li,{children:"store the new state"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Fmodel offers application interfaces/components which are actually composed out of repository interfaces/components (side effects) and core domain components (decision-making):"}),"\n",(0,a.jsx)(n.h2,{id:"event-sourced-vs-state-stored",children:"Event-Sourced vs State-Stored"}),"\n",(0,a.jsxs)(o.A,{groupId:"system-type",queryString:"system-type",children:[(0,a.jsxs)(s.A,{value:"event-stored",label:"Event-Stored / Event-Sourced",children:[(0,a.jsx)(n.p,{children:"Event-stored systems are split to command and view/query models, by default.\nThis is making a huge difference as we are not limited to use a single canonical model for writing and\nreading/presenting!"}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"event-modeling-event-driven-systems",src:t(8946).A+"",width:"5391",height:"3776"})}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Event-sourcing Aggregate"})," is a formalization of the event-stored/event-sourced system (Command\nModel) ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/application/architecture#event-stored-or-state-stored-systems",children:"mentioned previously"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"interface IEventSourcingAggregate<C, S, E, V, CM, EM>\ninterface EventSourcingOrchestratingAggregate<C, S, E>\ninterface IMaterializedView<S, E, V, EM>\ninterface ISagaManager<AR, A, ARM, AM>\n"})}),(0,a.jsxs)(n.p,{children:["Event-sourcing Aggregate is using/delegating a ",(0,a.jsx)(n.code,{children:"Decider"})," to handle commands and produce events. It belongs to the\nApplication layer. In order to\nhandle the command, aggregate needs to fetch the current state (represented as a list of events)\nvia ",(0,a.jsx)(n.code,{children:"EventRepository.fetchEvents"})," function, and then delegate the command to the decider which can produce new events as\na result. Produced events are then stored via ",(0,a.jsx)(n.code,{children:"EventRepository.save"})," suspending function."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"/**\n * Event sourcing aggregate interface is using/delegating a `decider` of type `IDecider`<`C`, `S`, `E`> to handle commands and produce events.\n * In order to handle the command, aggregate needs to fetch the current state (represented as a list of events) via `IEventRepository.fetchEvents` function, and then delegate the command to the `decider` which can produce new event(s) as a result.\n *\n * Produced events are then stored via `IEventRepository.save` function.\n *\n * @typeParam C - Commands of type `C` that this aggregate can handle\n * @typeParam S - Aggregate state of type `S`\n * @typeParam E - Events of type `E` that this aggregate can publish\n * @typeParam V - Version\n * @typeParam CM - Command Metadata\n * @typeParam EM - Event Metadata\n *\n */\nexport interface IEventSourcingAggregate<C, S, E, V, CM, EM>\n  extends IDecider<C, S, E>,\n    IEventRepository<C, E, V, CM, EM> {\n  /**\n   * Handles the command of type `C`, and returns new persisted list of pairs of event and its version.\n   *\n   * @param command - Command of type `C` with Command Metadata\n   * @return list of persisted events with Version and Event Metadata\n   */\n  readonly handle: (command: C & CM) => Promise<readonly (E & V & EM)[]>;\n}\n\n/**\n * Event sourcing orchestrating aggregate interface is using/delegating a `decider` of type `IDecider`<`C`, `S`, `E`> to handle commands and produce events.\n * In order to handle the command, aggregate needs to fetch the current state (represented as a list of events) via `IEventRepository.fetchEvents` function, and then delegate the command to the `decider` which can produce new event(s) as a result.\n *\n * If the `decider` is combined out of many deciders via `combine` function, an optional `EventSourcingOrchestratingAggregate.saga` could be used to react on new events and send new commands to the `decider` recursively, in one transaction.\n *\n * Produced events are then stored via `IEventRepository.save` function.\n *\n * @typeParam C - Commands of type `C` that this aggregate can handle\n * @typeParam S - Aggregate state of type `S`\n * @typeParam E - Events of type `E` that this aggregate can publish\n * @typeParam V - Version\n * @typeParam CM - Command Metadata\n * @typeParam EM - Event Metadata\n *\n */\nexport interface IEventSourcingOrchestratingAggregate<C, S, E, V, CM, EM>\n  extends IEventSourcingAggregate<C, S, E, V, CM, EM>,\n    ISaga<E, C> {}\n"})}),(0,a.jsxs)(o.A,{groupId:"style",queryString:"style",children:[(0,a.jsxs)(s.A,{value:"monolith",label:"monolith",children:[(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=decider",children:"combined/aggregated"})," in one big decider and then\nwrapped by one aggregate component:"]})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<\n  RestaurantCommand,\n  Restaurant | null,\n  RestaurantEvent\n>;\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>;\n\nclass AggregateEventRepository\n  implements\n    IEventRepository<\n      Command,\n      Event,\n      StreamVersion,\n      CommandMetadata,\n      EventMetadata\n    > {\n  // Implement the repository using the DB you find fit!\n}\n\nconst eventRepository = new AggregateEventRepository();\n\nconst aggregate: ApplicationAggregate = new EventSourcingAggregate(\n  restaurantDecider.combine(orderDecider),\n  eventRepository\n);\n\n/**\n * Start handling all commands!\n */\nconst result = await aggregate.handle(command);\n"})})]}),(0,a.jsxs)(s.A,{value:"monolith-orchestrated",label:"monolith orchestrated",children:[(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=decider",children:"combined/aggregated"})," in one big decider, additionally Order and Restaurant sagas are ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=saga",children:"combined"})," into one orchestrating saga.\nDecider and Saga are then wrapped by one aggregate component. Saga is responsible to integrate deciders internally, and enable event of one decider to trigger command of another, automatically"]})}),(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Events produced by both deciders belong to the same transaction, and they are immediately consistent."})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<RestaurantCommand,Restaurant | null, RestaurantEvent>\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>\nconst restaurantSaga: Saga<OrderEvent, RestaurantCommand>\nconst orderSaga: Saga<RestaurantEvent, OrderCommand>\n\nclass AggregateEventRepository implements\n  IEventRepository<\n    Command,\n    Event,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst eventRepository = new AggregateEventRepository ...\n\nconst aggregate: ApplicationAggregate = new EventSourcingOrchestratingAggregate(\n        restaurantDecider.combine(orderDecider),\n        eventRepository,\n        restaurantSaga.combine(orderSaga),\n      );\n\n/**\n * Start handling all your commands, inculding Restaurant and Order!\n */\nconst result = await aggregate.handle(command)\n"})})]}),(0,a.jsxs)(s.A,{value:"distributed",label:"distributed",children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents:"})}),(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"In distributed scenario, all aggregate components could be deployed as independent applications"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<RestaurantCommand, Restaurant | null, RestaurantEvent>\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>\n\nclass RestaurantAggregateEventRepository implements\n  IEventRepository<\n    RestaurantCommand,\n    RestaurantEvent,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst restaurantEventRepository = new RestaurantAggregateEventRepository ...\n\nclass OrderAggregateEventRepository implements\n  IEventRepository<\n    OrderCommand,\n    OrderEvent,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst orderEventRepository = new OrderAggregateEventRepository ...\n\n\nconst restaurantAggregate = new EventSourcingAggregate(\n        restaurantDecider,\n        restaurantEventRepository\n      );\n\nconst orderAggregate = new EventSourcingAggregate(\n        orderDecider,\n        orderEventRepository\n      );\n\n\n/**\n * Start handling your Restaurant commands!\n */\nconst result1 = await restaurantAggregate.handle(restaurantCommand)\n\n/**\n * Start handling your Order commands!\n */\nconst result2 = await orderAggregate.handle(orderCommand)\n"})})]}),(0,a.jsxs)(s.A,{value:"distributed-orchestrated",label:"distributed orchestrated",children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents, and Order and Restaurant sagas are combined into one Saga and wrapped by unique Saga Manager:"})}),(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"In distributed scenario, all aggregate and saga manager component(s) could be deployed as independent applications, communicating over the wire."}),(0,a.jsx)(n.p,{children:"In this scenario we have three components on the application layer that should communicate to each other over the wire:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"orderAggregate (app1)"}),"\n",(0,a.jsx)(n.li,{children:"restaurantAggregate (app2)"}),"\n",(0,a.jsx)(n.li,{children:"orchestratedSagaManager (app3)"}),"\n"]}),(0,a.jsxs)(n.p,{children:["The combined (orchestrating) ",(0,a.jsx)(n.code,{children:"orchestratedSagaManager"})," will react on events (",(0,a.jsx)(n.strong,{children:"over the wire"}),") produced by both aggregates and send commands (",(0,a.jsx)(n.strong,{children:"over the wire"}),") to these aggregates."]})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<RestaurantCommand, Restaurant | null, RestaurantEvent>\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>\nconst restaurantSaga: Saga<OrderEvent, RestaurantCommand>\nconst orderSaga: Saga<RestaurantEvent, OrderCommand>\n\nclass RestaurantAggregateEventRepository implements\n  IEventRepository<\n    RestaurantCommand,\n    RestaurantEvent,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst restaurantEventRepository = new RestaurantAggregateEventRepository ...\n\nclass OrderAggregateEventRepository implements\n  IEventRepository<\n    OrderCommand,\n    OrderEvent,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst orderEventRepository = new OrderAggregateEventRepository ...\n\nconst sagaPublisher = new ActionPublisher ...\n\n\n\n\nconst restaurantAggregate = new EventSourcingAggregate(\n        restaurantDecider,\n        restaurantEventRepository\n      );\n\nconst orderAggregate = new EventSourcingAggregate(\n        orderDecider,\n        orderEventRepository\n      );\n\n\n/**\n * Start handling your Restaurant commands!\n */\nconst result1 = await restaurantAggregate.handle(restaurantCommand)\n\n/**\n * Start handling your Order commands!\n */\nconst result2 = await orderAggregate.handle(orderCommand)\n\n/**\n * Additionally, a single, orchestratig sagaManager is reacting on events from one aggregate and publishes command to the other.\n */\nconst orchestratedSagaManager = new SagaManager(\n   restaurantSaga.combine(orderSaga),\n   sagaPublisher\n)\n"})})]}),(0,a.jsxs)(s.A,{value:"distributed-choreography",label:"distributed choreography",children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents, and Order and Restaurant sagas are wrapped by independent Saga managers:"})}),(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsx)(n.p,{children:"In distributed scenario, all aggregate and corresponding saga manager component(s) could be deployed as independent applications, communicating over the wire."}),(0,a.jsx)(n.p,{children:"In this scenario we have four components on the application layer that should communicate to each other over the wire:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"orderAggregate (app1)"}),"\n",(0,a.jsx)(n.li,{children:"orderSagaManager (app1)"}),"\n",(0,a.jsx)(n.li,{children:"restaurantAggregate (app2)"}),"\n",(0,a.jsx)(n.li,{children:"restaurantSagaManager (app2)"}),"\n"]}),(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"orderSagaManager / restaurantSagaManager"})," will react on events (",(0,a.jsx)(n.strong,{children:"over the wire"}),") produced by aggregates and send commands (",(0,a.jsx)(n.strong,{children:"locally"}),") to the appropriate aggregate(s)."]})]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<RestaurantCommand, Restaurant | null, RestaurantEvent>\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>\nconst restaurantSaga: Saga<OrderEvent, RestaurantCommand>\nconst orderSaga: Saga<RestaurantEvent, OrderCommand>\n\nclass RestaurantAggregateEventRepository implements\n  IEventRepository<\n    RestaurantCommand,\n    RestaurantEvent,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst restaurantEventRepository = new RestaurantAggregateEventRepository ...\n\nclass OrderAggregateEventRepository implements\n  IEventRepository<\n    OrderCommand,\n    OrderEvent,\n    StreamVersion,\n    CommandMetadata,\n    EventMetadata\n  > {\n   // Implement the repository using the DB you find fit!\n  }\n\nconst orderEventRepository = new OrderAggregateEventRepository ...\n\nconst restaurantPublisher = new ActionPublisher ...\nconst orderPublisher = new ActionPublisher ...\n\n\n\n\nconst restaurantAggregate = new EventSourcingAggregate(\n        restaurantDecider,\n        restaurantEventRepository\n      );\n\nconst orderAggregate = new EventSourcingAggregate(\n        orderDecider,\n        orderEventRepository\n      );\n\n\n/**\n * Start handling your Restaurant commands!\n */\nconst result1 = await restaurantAggregate.handle(restaurantCommand)\n\n/**\n * Start handling your Order commands!\n */\nconst result2 = await orderAggregate.handle(orderCommand)\n\n/**\n * Additionally, a independent, choreography sagaManagers are reacting on events from one aggregate and publishes command to the other.\n */\nconst restaurantSagaManager = new SagaManager(\n   restaurantSaga,\n   restaurantPublisher\n)\n\nconst orderSagaManager = new SagaManager(\n   orderSaga,\n   orderPublisher\n)\n"})})]})]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Materialized View"})," is a formalization of the event-stored/event-sourced system (View\nModel) ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/application/architecture#event-stored-or-state-stored-systems",children:"mentioned previously"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export interface IMaterializedView<S, E, V, EM>\n  extends IView<S, E>,\n    IViewStateRepository<E, S, V, EM>\n"})}),(0,a.jsxs)(n.p,{children:["Materialized view is using/delegating a ",(0,a.jsx)(n.code,{children:"View"})," (domain component) to handle events of type ",(0,a.jsx)(n.code,{children:"E"})," and to maintain a state\nof denormalized projection(s) as a result."]}),(0,a.jsxs)(o.A,{groupId:"style",queryString:"style",children:[(0,a.jsxs)(s.A,{value:"monolith",label:"monolith",children:[(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Example of a monolith scenario, in which Order and Restaurant views\nare ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=view",children:"combined"})," in one big view and then wrapped by one\nmaterialized-view component:"]})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantView: View<RestaurantView | null, RestaurantEvent>;\nconst orderView: View<OrderView | null, OrderEvent>;\n\nconst viewRepository: IViewStateRepository<\n  RestaurantEvent | OrderEvent,\n  ViewState,\n  StreamVersion,\n  EventMetadata\n> = new DenoViewStateRepository(kv);\n\nconst materializedView: ApplicationMaterializedView = new MaterializedView(\n  restaurantView.combine(orderView),\n  viewRepository\n);\n\n// Handle the events of all types\nconst result = await materializedView.handle(event);\n"})})]}),(0,a.jsxs)(s.A,{value:"distributed",label:"distributed",children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Example of a distributed scenario, in which Order and Restaurant views are wrapped by independent materialized-view\ncomponents:"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantView: View<RestaurantView | null, RestaurantEvent>;\nconst orderView: View<OrderView | null, OrderEvent>;\n\nconst restaurantViewRepository: IViewStateRepository<\n  RestaurantEvent,\n  RestaurantViewState,\n  StreamVersion,\n  EventMetadata\n> = new DenoRestaurantViewStateRepository(kv);\n\nconst orderViewRepository: IViewStateRepository<\n  OrderEvent,\n  OrderViewState,\n  StreamVersion,\n  EventMetadata\n> = new DenoOrderViewStateRepository(kv);\n\nconst restaurantMaterializedView = new MaterializedView(\n  restaurantView,\n  restaurantViewRepository\n);\n\nconst orderMaterializedView = new MaterializedView(\n  orderView,\n  orderViewRepository\n);\n\n// Handle the restaurant events\nconst result1 = await restaurantMaterializedView.handle(event);\n// Handle the order events\nconst result2 = await orderMaterializedView.handle(event);\n"})})]})]})]}),(0,a.jsxs)(s.A,{value:"state-stored",label:"State-Stored",children:[(0,a.jsx)(n.p,{children:"State-stored systems are using single canonical model for writing and reading/presenting, by default."}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"event-modeling-traditional-systems",src:t(7852).A+"",width:"5480",height:"5461"})}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"State-stored Aggregate"})," is a formalization of the state-stored\nsystem ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/application/architecture#event-stored-or-state-stored-systems",children:"mentioned previously"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export interface IStateStoredAggregate<C, S, E, V, CM, SM>\n  extends IDecider<C, S, E>,\n    IStateRepository<C, S, V, CM, SM> {\n  readonly handle: (command: C & CM) => Promise<S & V & SM>;\n}\n\nexport interface IStateStoredOrchestratingAggregate<C, S, E, V, CM, SM>\n  extends IStateStoredAggregate<C, S, E, V, CM, SM>,\n    ISaga<E, C> {}\n"})}),(0,a.jsxs)(n.p,{children:["State-stored Aggregate is using/delegating a ",(0,a.jsx)(n.code,{children:"Decider"})," to handle commands and produce new state. It belongs to the\nApplication layer. In order to\nhandle the command, aggregate needs to fetch the current state via ",(0,a.jsx)(n.code,{children:"StateRepository.fetchState"})," function first, and then\ndelegate the command to the decider which can produce new state as a result. New state is then stored\nvia ",(0,a.jsx)(n.code,{children:"StateRepository.save"})," suspending function."]}),(0,a.jsxs)(o.A,{groupId:"style",queryString:"style",children:[(0,a.jsxs)(s.A,{value:"monolith",label:"monolith",children:[(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=decider",children:"combined/aggregated"})," in one big decider and then\nwrapped by one aggregate component:"]})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<\n  RestaurantCommand,\n  Restaurant | null,\n  RestaurantEvent\n>;\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>;\n\nclass AggregateStateRepository\n  implements\n    IStateRepository<\n      Command,\n      (Restaurant & Order) | null,\n      StreamVersion,\n      CommandMetadata,\n      StateMetadata\n    > {\n  // Implement the repository using the DB you find fit!\n}\n\nconst stateRepository = new AggregateStateRepository();\n\nconst aggregate: ApplicationAggregate = new StateStoredAggregate(\n  restaurantDecider.combine(orderDecider),\n  stateRepository\n);\n\n/**\n * Start handling all commands!\n */\nconst result = await aggregate.handle(command);\n"})})]}),(0,a.jsx)(s.A,{value:"monolith-orchestrated",label:"monolith orchestrated",children:(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Example of a monolith scenario, in which Order and Restaurant deciders\nare ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=decider",children:"combined/aggregated"})," in one big decider, additionally Order and Restaurant sagas are ",(0,a.jsx)(n.a,{href:"/fmodel-ts/docs/domain/aggregating-the-behaviour?component-type=saga",children:"combined"})," into one orchestrating saga.\nDecider and Saga are then wrapped by one aggregate component.\nSaga is responsible to integrate deciders internally, and enable event of one decider to trigger command of another, automatically"]})})}),(0,a.jsxs)(s.A,{value:"distributed",label:"distributed",children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Example of a distributed scenario, in which Order and Restaurant deciders are wrapped by independent aggregate\ncomponents:"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const restaurantDecider: Decider<\n  RestaurantCommand,\n  Restaurant | null,\n  RestaurantEvent\n>;\nconst orderDecider: Decider<OrderCommand, Order | null, OrderEvent>;\n\nclass RestaurantAggregateStateRepository\n  implements\n    IStateRepository<\n      RestaurantCommand,\n      Restaurant | null,\n      StreamVersion,\n      CommandMetadata,\n      StateMetadata\n    > {\n  // Implement the repository using the DB you find fit!\n}\n\nclass OrdertAggregateStateRepository\n  implements\n    IStateRepository<\n      OrderCommand,\n      Order | null,\n      StreamVersion,\n      CommandMetadata,\n      StateMetadata\n    > {\n  // Implement the repository using the DB you find fit!\n}\n\nconst restaurantStateRepository = new RestaurantAggregateStateRepository();\nconst orderStateRepository = new OrderAggregateStateRepository();\n\nconst restaurantAggregate: ApplicationAggregate = new StateStoredAggregate(\n  restaurantDecider,\n  restaurantStateRepository\n);\n\nconst orderAggregate: ApplicationAggregate = new StateStoredAggregate(\n  orderDecider,\n  orderStateRepository\n);\n\n/**\n * Start handling restaurant commands!\n */\nconst result1 = await restaurantAggregate.handle(command);\n/**\n * Start handling order commands!\n */\nconst result2 = await orderAggregate.handle(command);\n"})})]})]})]})]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var a=t(4164);const r={tabItem:"tabItem_Ymn6"};var o=t(4848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>x});var a=t(6540),r=t(4164),o=t(3104),s=t(6347),i=t(205),d=t(7485),c=t(1682),l=t(679);function g(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return g(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,d.aZ)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function h(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=u(e),[s,d]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[c,g]=p({queryString:t,groupId:r}),[h,v]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,o]=(0,l.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),y=(()=>{const e=c??h;return m({value:e,tabValues:o})?e:null})();(0,i.A)((()=>{y&&d(y)}),[y]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);d(e),g(e),v(e)}),[g,v,o]),tabValues:o}}var v=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(4848);function E(e){let{className:n,block:t,selectedValue:a,selectValue:s,tabValues:i}=e;const d=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),l=e=>{const n=e.currentTarget,t=d.indexOf(n),r=i[t].value;r!==a&&(c(n),s(r))},g=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>d.push(e),onKeyDown:g,onClick:l,...o,className:(0,r.A)("tabs__item",y.tabItem,o?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function w(e){let{lazy:n,children:t,selectedValue:o}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===o));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function b(e){const n=h(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",y.tabList),children:[(0,f.jsx)(E,{...n,...e}),(0,f.jsx)(w,{...n,...e})]})}function x(e){const n=(0,v.A)();return(0,f.jsx)(b,{...e,children:g(e.children)},String(n))}},8946:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/event-modeling-event-driven-systems-dd36561b4d665e5dfcc97acc8fccbf92.png"},7852:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/event-modeling-traditional-systems-1f8ef3235fa73ccc9ec41b05082804da.png"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var a=t(6540);const r={},o=a.createContext(r);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);